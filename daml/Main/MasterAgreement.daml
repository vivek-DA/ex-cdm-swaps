-- Copyright (c) 2019, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module Main.MasterAgreement where

import Org.Isda.Cdm.EventSpecificationModule as Cdm hiding (Party, RefData)
import Main.Event.Instance
import Main.Event.Proposal hiding (Accept)
import Main.Market.Contract
import Main.ReferenceData
import Main.Types
import Main.Utils.Common
import Main.Utils.Cdm
import DA.List

---------------------------------------------- Instance ------------------------------------------------------
--------------------------------------------------------------------------------------------------------------

-- | Master Agreement used to trigger new events. This can either be the proposal of an event
-- (e.g. NewTrade, Termination, etc.) or the creation of a derived event.
template MasterAgreementInstance
  with
    p1  : Party
    p2  : Party
    -- ccp: Party
  where
    signatory p1, p2
    key (p1, p2): (Party, Party)
    maintainer key._1
    nonconsuming choice ProposeNewTrade: ContractId EventProposal
      with
        exerciser  : Party
        ps      : [PartyWithId]
        base    : BaseEvent
        after   : PostInceptionState
      controller exerciser
      do
        assertMsg "exerciser exists" $ p1 == exerciser || p2 == exerciser
        let spec = NewTradeSpec with ..
        event <- setEventRosettaKey $ Cdm.buildNewTradeEvent spec
        create EventProposal with ps, d = event, sigs = [exerciser]

    nonconsuming choice ProposeTermination: ContractId EventProposal
      with
        exerciser  : Party
        ps      : [PartyWithId]
        base    : BaseEvent
        ciCid   : ContractId ContractInstance
      controller exerciser
      do
        assertMsg "exerciser exists" $ p1 == exerciser || p2 == exerciser
        ci <- fetch ciCid
        let spec = TerminationSpec with contract = ci.d, ..
        event <- setEventRosettaKey $ Cdm.buildTerminationEvent spec
        create EventProposal with ps, d = event, sigs = [exerciser]

    nonconsuming choice ProposePartialTermination: ContractId EventProposal
      with
        exerciser  : Party
        ps      : [PartyWithId]
        base    : BaseEvent
        change  : [ContractualQuantity]
        ciCid   : ContractId ContractInstance
      controller exerciser
      do
        assertMsg "exerciser exists" $ p1 == exerciser || p2 == exerciser
        ci <- fetch ciCid
        let spec = PartialTerminationSpec with contract = ci.d, ..
        event <- setEventRosettaKey $ Cdm.buildPartialTerminationEvent spec
        create EventProposal with ps, d = event, sigs = [exerciser]

    nonconsuming choice ProposeNovation: [ContractId EventProposal]
      with
        exerciser      : Party
        ps          : [PartyWithId]
        base        : [BaseEvent]
        contractNew : [Contract]
        ciCid       : ContractId ContractInstance
      controller exerciser
      do
        assertMsg "exerciser exists" $ p1 == exerciser || p2 == exerciser
        ci <- fetch ciCid
        case  contractNew of
          [cn1,cn2] ->  do
              let ps1 = [ps!!0,ps!!2]
                  ps2 = [ps!!1,ps!!2]
                  ccp = ps!!2
                  spec1 = NovationSpec with contract = ci.d, contractNew = cn1,base=base!!0
                  spec2 = NovationSpec with contract = ci.d, contractNew = cn2,base=base!!1

              event1 <- setEventRosettaKey $ Cdm.buildNovationEvent spec1
              event2 <- setEventRosettaKey $ Cdm.buildNovationEvent spec2

              l1<- create EventProposal with ps=ps1, d = event1, sigs = [exerciser]
              l2<- create EventProposal with ps=ps2, d = event2, sigs = [exerciser]
              return [l1,l2]
          [cn1] ->   do
            let cn1 = contractNew!!0
                spec1 = NovationSpec with contract = ci.d, contractNew = cn1,base=base!!0
            event1 <- setEventRosettaKey $ Cdm.buildNovationEvent spec1

            l1<- create EventProposal with ps, d = event1, sigs = [exerciser]
            return [l1]
          _ -> error "Application Error"



    nonconsuming choice ProposePartialNovation: ContractId EventProposal
      with
        exerciser      : Party
        ps          : [PartyWithId]
        base        : BaseEvent
        change      : [ContractualQuantity]
        contractNew : Contract
        ciCid       : ContractId ContractInstance
      controller exerciser
      do
        assertMsg "exerciser exists" $ p1 == exerciser || p2 == exerciser
        ci <- fetch ciCid
        let spec = PartialNovationSpec with contract = ci.d, ..
        event <- setEventRosettaKey $ Cdm.buildPartialNovationEvent spec
        create EventProposal with ps, d = event, sigs = [exerciser]

    nonconsuming choice CreateDerivedEvent: ContractId EventInstance
      with
        exerciser  : Party
        refData : RefData
        ciCid   : ContractId ContractInstance
        event   : Event
      controller exerciser
      do
        assertMsg "exerciser exists" $ p1 == exerciser || p2 == exerciser
        ledgerTime <- getTime
        assertOnOrAfterDateMsg "can only create derived events after event date" event.eventDate

        -- Re-build derived events and check that the provided event is identical
        ci <- fetch ciCid
        lifecycleEvents <- mapA (\enCid -> do en <- fetch enCid; return en.d) ci.lifecycleEventCids
        let spec = DerivedSpec with
                    fromDate = Some event.eventDate
                    toDate = Some event.eventDate
                    pastEvents = lifecycleEvents
                    contract = ci.d

        eventNew <-
          setEventRosettaKey
          =<< (fromSomeTry "no events found" .
                find (\e -> e.effectiveDate == event.effectiveDate && e.eventQualifier == event.eventQualifier))
          =<< (flip Cdm.buildDerivedEvents) spec
          <$> toCdmRefData refData
        assertMsg "event has realized" (eventNew.primitive /= emptyPrimitiveEvent)

        -- Net transfers
        let eventNetted = eventNew with
                            primitive = eventNew.primitive with
                              transfer = Cdm.netTransfers eventNew.primitive.transfer

        create EventInstance with ps = ci.ps, d = eventNetted

---------------------------------------------- Proposal ------------------------------------------------------
--------------------------------------------------------------------------------------------------------------

template MasterAgreementProposal
  with
    p1  : Party
    p2  : Party
  where
    signatory p1

    controller p2 can
      Accept: ContractId MasterAgreementInstance
        do create MasterAgreementInstance with p1, p2
